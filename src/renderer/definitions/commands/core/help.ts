// file: src/renderer/src/definitions/commands/core/help.ts
import { CommandArg, CommandDefinition } from "../types";
import { coreCommands } from "@/renderer/definitions/commands/core/index.ts";

// Note: In the future, this could be dynamically generated by the command loader.

const TERMINAL_SPACING = 10;

export const helpCommand: CommandDefinition = {
  name: 'help',
  description: 'Displays a list of available commands.',
  soundBlueprint: {
    sources: [{ type: 'oscillator', oscillatorType: 'sine', frequency: 440 }],
    envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.1 },
    duration: 0.4
  },
  execute: (args = []) => {

    let helpText = 'Available commands: ';

    let commands = coreCommands;

    if (args.length > 0) {
      if (commands.map(m => m.name).includes(args[0].toLowerCase())) {
        helpText = 'Available sub-commands: ';
        commands = commands.filter(command => command.name === args[0]);
      }
    }
    for (const command of commands) {
      helpText += `\n${command.name.padEnd(TERMINAL_SPACING * 3)}${command.description}`;

      if (command.argSet) {
        command.argSet.forEach(arg => {
          helpText += `\n${mapHelpArg(arg)}`;
        });
      }
    }


    return {
      output: helpText
    }
  },
  argSet: []
}

function mapHelpArg(arg: CommandArg, depth = 1): string {

  if (typeof arg == 'string') return arg;

  if (depth >= 5) return '`' + (arg.placeholder ?? arg) + '`';

  let argText = [
    '\t'.repeat(depth)
  ];
  if (arg.flag || arg.placeholder) {
    argText = argText.concat([[
      ...(arg.flag ? [arg.flag] : []),
      ...(arg.placeholder  ? [`<${arg.placeholder}>`] : []),
    ].join(' ')])
  }
  else if (arg.literal) {
    argText.push(`${arg.literal}:`);
  }
  if (arg.description) {
    argText.push(`\t${arg.description}`);
  }

  if (arg.args) {
    arg.args.map((a) => mapHelpArg(a, depth + 1))
      .forEach((result) => {
        argText.push(`${result}`);
      })
  }

  return argText.join('');

}
